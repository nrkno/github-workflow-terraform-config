on:
  workflow_call:
    inputs:
      terraform-job-enabled:
        type: boolean
        default: true
      terraform-version:
        type: string
        default: latest
      working-directory:
        type: string
        default: .
      ignore-files:
        type: string
        default: ""
      status-comment-enabled:
        type: boolean
        default: true
      status-comment-message:
        type: string
        default: ""
      runs-on:
        type: string
        default: self-hosted
      trivy-job-enabled:
        type: boolean
        default: true
      trivy-ignore-unfixed:
        type: boolean
        default: true
      trivy-sbom-enabled:
        type: boolean
        default: false
      trivy-severity:
        type: string
        default: MEDIUM,HIGH,CRITICAL
      trivy-ignore-files:
        type: string
        default: ""
      trivy-error-is-success:
        type: boolean
        default: false
      terraform-docs-job-enabled:
        type: boolean
        default: true
      terraform-docs-config-file:
        type: string
        default: .terraform-docs.yaml
      terraform-docs-output-file:
        type: string
        default: README.md
      terraform-docs-output-method:
        type: string
        default: inject
      terraform-docs-git-commit-message:
        type: string
        default: "docs: terraform-docs automated update"
      terraform-docs-git-push:
        type: boolean
        default: true
      terraform-docs-fail-on-diff:
        type: boolean
        default: false
      terraform-docs-recursive:
        type: boolean
        default: false
      # Toggles used for setting environment variables in this workflow.
      # It is not possible to pass env vars directly to reusable workflows.
      enable-azurerm-3-beta-resources:
        type: boolean
        default: false
    secrets:
      registries:
        required: false
      ssh-private-key:
        required: true
      ssh-private-key-docs-push:
        required: false
      token:
        required: true

name: Terraform
jobs:
  terraform:
    name: Config Validation in ${{ inputs.working-directory }}
    runs-on: ${{ inputs.runs-on }}
    if: inputs.terraform-job-enabled
    steps:
      # Work-around for not being able to test if a secret has been set when
      # using `if` for conditional step execution.
      - name: Determine need for SSH agent
        id: ssh-agent-test
        shell: bash
        env:
          SSH_PRIVATE_KEY: ${{ secrets.ssh-private-key }}
        run: |
          set +e
          test -n "${SSH_PRIVATE_KEY}"
          echo "::set-output name=exit_code::${?}"

      # SSH agent used to checkout Terraform modules from other private repos on Github.
      - name: Setup SSH agent
        uses: webfactory/ssh-agent@v0.5.4
        if: steps.ssh-agent-test.outputs.exit_code == '0'
        with:
          ssh-private-key: ${{ secrets.ssh-private-key }}

      - name: Configure secrets
        shell: bash
        env:
          REGISTRIES: "${{ secrets.registries }}"
        run: |
          export IFS=';'
          for registry in $REGISTRIES
          do
            echo $registry
            IFS="=" read domain token <<<$registry
            tokenvar="TF_TOKEN_$(tr . _ <<<$domain | sed s/-/__/g)"
            echo "Setting ${tokenvar} for ${domain}"
            echo "${tokenvar}=${token}" >> "${GITHUB_ENV}"
          done

      - name: Configure environment
        run: |
          set +ex
          if [ '${{ inputs.enable-azurerm-3-beta-resources }}' = 'true' ]; then
            echo 'ARM_THREEPOINTZERO_BETA_RESOURCES=true' >> $GITHUB_ENV
          fi

      - name: Checkout
        uses: actions/checkout@v3

      # Delete ignored files inside repo before running Terraform.
      # This is useful e.g. if the repository has configured a Terraform
      # backend that should not be used when simply validating the
      # configuration. Care is taken to prevent deletion of files outside
      # of the repository root.
      - name: Remove ignored files
        if: inputs.ignore-files != ''
        env:
          IGNORE_FILES: ${{ inputs.ignore-files }}
        shell: python
        working-directory: ${{ inputs.working-directory }}
        run: |
          import os
          import pathlib
          import shutil

          fpaths = os.getenv("IGNORE_FILES", "")
          for fpath in [s.strip() for s in fpaths.split(",") if s]:
            # Make sure we only delete files in repo root
            safe_dir = os.getcwd() + os.sep
            if not os.path.commonprefix((os.path.realpath(fpath),safe_dir)) == safe_dir:
              raise ValueError(f"Not allowed to delete path outside of repo root: {fpath}")

            # Delete path
            p = pathlib.Path(fpath)
            if p.is_file():
              p.unlink()
              print("deleted file:", p.name)
            elif p.is_dir():
              shutil.rmtree(p.name)
              print("deleted directory:", p.name)

      - name: Configure Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: ${{ inputs.terraform-version }}
          terraform_wrapper: false

      - name: 'Run: terraform fmt'
        id: fmt
        shell: bash
        working-directory: ${{ inputs.working-directory }}
        run: |
          set +e
          terraform fmt -check -recursive -list=true
          echo "::set-output name=exit_code::${?}"
        continue-on-error: true

      - name: 'Run: terraform init'
        id: init
        shell: bash
        working-directory: ${{ inputs.working-directory }}
        run: |
          set +e
          terraform init -no-color
          echo "::set-output name=exit_code::${?}"
        continue-on-error: true

        # workaround for https://github.com/hashicorp/terraform/issues/28490
      - uses: actions/setup-go@v3
        with:
          go-version: '1.16.15'
      - name: 'Run terraform configuration aliases'
        uses: bendrucker/terraform-configuration-aliases-action@v1
        with:
          path: ${{ inputs.working-directory }}

      - name: 'Run: terraform validate'
        id: validate
        shell: bash
        working-directory: ${{ inputs.working-directory }}
        run: |
          set +e
          terraform validate -no-color
          echo "::set-output name=exit_code::${?}"
        continue-on-error: true

      - name: Post results as comment
        uses: actions/github-script@v6
        if: github.event.pull_request && github.actor != 'dependabot[bot]' && inputs.status-comment-enabled
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const bool_emoji = (v) => Boolean(v) ? '✔️' : '❌';
            const data = {
              url: 'https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}',
              fmt: bool_emoji(${{ steps.fmt.outputs.exit_code == '0' }}),
              init: bool_emoji(${{ steps.init.outputs.exit_code == '0' }}),
              validate: bool_emoji(${{ steps.validate.outputs.exit_code == '0' }}),
              status: Boolean(${{ steps.fmt.outputs.exit_code == '0' && steps.init.outputs.exit_code == '0' && steps.validate.outputs.exit_code == '0' }})
            }
            const body = `format: ${data.fmt} | init: ${data.init} | validate: ${data.validate}\n[check](${data.url}) ${data.status ? 'succeeded' : 'failed'}:\n\n${{ inputs.status-comment-message }}`;
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body,
            });

      - name: 'Determine job exit status'
        shell: python
        run: |
          import sys

          test_cases = dict(
            fmt="${{ steps.fmt.outputs.exit_code }}",
            init="${{ steps.init.outputs.exit_code }}",
            validate="${{ steps.validate.outputs.exit_code }}",
          )

          failed = False
          for name, exit_code in test_cases.items():
            success = exit_code == "0"
            print(name, success)
            if not success:
              failed = True

          if failed:
            sys.exit(1)

  trivy:
    name: Trivy Vulnerability Scan in ${{ inputs.working-directory }}
    runs-on: ${{ inputs.runs-on }}
    if: inputs.trivy-job-enabled
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Configure Python
        uses: actions/setup-python@v4
        with:
          python-version: 3.9

      - name: Parse ignore files
        shell: python
        env:
          WORKING_DIRECTORY: ${{ inputs.working-directory }}
          IGNORE_FILES: ${{ inputs.trivy-ignore-files }}
        run: |
          import os

          gh_env_file = os.getenv("GITHUB_ENV")
          workdir = os.getenv("WORKING_DIRECTORY")
          ignorefiles = os.getenv("IGNORE_FILES")

          paths = []
          for p in [p.strip() for p in ignorefiles.split(",") if p]:
            paths.append(os.path.join(workdir, p))

          if paths:
            with open(gh_env_file, 'a') as f:
              print("TRIVYIGNORE_PATHS", ",".join(paths), sep="=", file=f)

      - name: Scan IaC code
        uses: aquasecurity/trivy-action@0.7.1
        id: trivy-scan
        with:
          exit-code: '0'
          format: json
          hide-progress: false
          ignore-unfixed: ${{ inputs.trivy-ignore-unfixed }}
          output: .trivy-scan-result.json
          scan-ref: ${{ inputs.working-directory }}
          scan-type: config
          severity: ${{ inputs.trivy-severity }}
          trivyignores: ${{ env.TRIVYIGNORE_PATHS }}

      - name: Parse scan results
        shell: python
        env:
          RESULT_FILENAME: .trivy-scan-result.json
        continue-on-error: ${{ inputs.trivy-error-is-success }}
        run: |
          import json
          import os
          import sys

          result_filename = os.getenv("RESULT_FILENAME")


          def create_output(filename, error):
              severity = "warning"
              if error["Severity"] in ("HIGH", "CRITICAL"):
                  severity = "error"
              message = f"{error['ID']}: {error['Title']}%0A{error['Description']}%0A{error['Message']}%0AResolution: {error['Resolution']}%0A"
              for reference in error["References"]:
                  message += f"%0A{reference}"
              start_line = error["CauseMetadata"]["StartLine"]
              end_line = error["CauseMetadata"]["EndLine"]
              print(
                  f"::{severity} file={filename},line={start_line},endLine={end_line}::{message}"
              )


          with open(result_filename, "r") as result_file:
              output = json.load(result_file)
              results = output.get("Results", [])
              exit_status = 0

              for result in results:
                  for misconfiguration in result.get("Misconfigurations", []):
                      # Since severity filter is set at job level, we can exit non-zero for all
                      # errors regardless of severity and let workflow consumers decide which
                      # severity levels to care about.
                      exit_status = 1
                      create_output(result["Target"], misconfiguration)

              sys.exit(exit_status)

  trivy-sbom:
    name: Generate SBOM in ${{ inputs.working-directory }}
    runs-on: ${{ inputs.runs-on }}
    if: inputs.trivy-sbom-enabled
    steps:
      - name: Checkout
        uses: actions/checkout@v3
      - name: Submit SBOM results to Dependency Snapshots
        uses: aquasecurity/trivy-action@0.7.1
        with:
          scan-type: 'fs'
          format: 'github'
          output: 'dependency-results.sbom.json'
          image-ref: '.'
          github-pat: '${{ secrets.GITHUB_TOKEN }}'

  terraform-docs:
    name: Render terraform docs in ${{ inputs.working-directory }}
    runs-on: ${{ inputs.runs-on }}
    if: inputs.terraform-docs-job-enabled && github.ref != 'refs/heads/master' && github.ref != 'refs/heads/main'
    needs: [terraform]
    concurrency: terraform-docs
    steps:
      - name: Check ssh key for checkout and push
        id: ssh_key_check
        shell: bash
        env:
          SSH_PRIVATE_KEY: "${{ secrets.ssh-private-key-docs-push }}"
        run: |
          set +e
          if test -n "${SSH_PRIVATE_KEY}"
          then
            echo "::set-output name=has_ssh_key::yes"
          else
            echo "::set-output name=has_ssh_key::no"
          fi
      - name: Checkout
        uses: actions/checkout@v3
        if: ${{ steps.ssh_key_check.outputs.has_ssh_key == 'yes' }}
        with:
          ref: "${{ github.head_ref }}"
          ssh-key: "${{ secrets.ssh-private-key-docs-push }}"
      - name: Checkout
        uses: actions/checkout@v3
        if: ${{ steps.ssh_key_check.outputs.has_ssh_key  != 'yes' }}
        with:
          ref: "${{ github.head_ref }}"
      - name: Checkout workflow
        id: checkout_workflow
        uses: actions/checkout@v3
        with:
          repository: nrkno/github-workflow-terraform-config
          ref: ${{ needs.setup.outputs.workflow_tag }}
          path: .github-workflow-terraform-config
      - name: Get workflow ref
        id: workflow_tag
        shell: bash
        run: |
          workflow_file="${GITHUB_WORKFLOW}"
          if ! [ -f "${workflow_file}" ]
          then
            workflow_file="$(grep -l "^name: ${GITHUB_WORKFLOW}$" .github/workflows/*)"
          fi
          workflow_tag="$(awk -F @ '/github-workflow-terraform-config/ {print $2}' "${workflow_file}")"
          echo "::set-output name=workflow_tag::${workflow_tag}"
      - name: Set configuration
        id: set_config
        shell: bash
        env:
          CONFIG_FILE: ${{ inputs.terraform-docs-config-file }}
        run: |
          if [ -f "$CONFIG_FILE" ]
          then
            echo "Using callers configuration for commitlint"
          else
            echo "Using workflow configuration for commitlint"
            cp -- "${GITHUB_WORKSPACE}/.github-workflow-terraform-config/.terraform-docs.yaml" "$CONFIG_FILE"
          fi
          # workaround for terraform docs trigger happy git add
          echo "$CONFIG_FILE" >> .gitignore
      - name: Remove workflow checkout
        shell: bash
        run: |
          rm -rf -- .github-workflow-terraform-config
      - name: Render terraform docs and push
        uses: terraform-docs/gh-actions@v1.0.0
        with:
          working-dir: ${{ inputs.working-directory }}
          config-file: ${{ inputs.terraform-docs-config-file }}
          fail-on-diff: ${{ inputs.terraform-docs-fail-on-diff }}
          recursive: ${{ inputs.terraform-docs-recursive }}
          output-file: ${{ inputs.terraform-docs-output-file }}
          output-method: ${{ inputs.terraform-docs-output-method }}
          git-push: false
      - name: Commit doc updates
        if: ${{ steps.ssh_key_check.outputs.has_ssh_key == 'yes' && inputs.terraform-docs-git-push }}
        shell: bash
        env:
          COMMIT_MESSAGE: ${{ inputs.terraform-docs-git-commit-message }}
        run: |
          # restore gitignore workaround
          git checkout .gitignore
          if [ $(git status --porcelain | grep -c -E '*.\.md$') -eq 0 ]
          then
            echo "No changes to .md files"
            exit 0
          fi
          # sometimes cleanup fails, workaround
          sudo chown -R -- $(id -u) .git
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git add $(git status --porcelain | awk '/.*\.md$/ { print $2 }')
          git commit -m "$COMMIT_MESSAGE"
          git push
